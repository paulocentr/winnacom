import crypto from 'crypto';
import { getFloats, verify, PAYOUTS, PROB_TABLES } from '../verifier.js';

console.log('--- crypto audit ---\n');

const serverSeed = 'test_server_seed_12345';
const clientSeed = 'test_client';

// hmac vs plain sha256 check
// byte generator uses HMAC-SHA256(serverSeed, clientSeed:nonce:cursor)
console.log('hmac vs sha256:');
const msg = `${clientSeed}:0:0`;
const hmac = crypto.createHmac('sha256', serverSeed).update(msg).digest();
const plain = crypto.createHash('sha256').update(serverSeed + msg).digest();

// get float from our verifier and rebuild manually from raw hmac
const [ourFloat] = getFloats(serverSeed, clientSeed, 0, 1);
const hmacFloat = hmac[0]/256 + hmac[1]/65536 + hmac[2]/16777216 + hmac[3]/4294967296;
const plainFloat = plain[0]/256 + plain[1]/65536 + plain[2]/16777216 + plain[3]/4294967296;

console.log('  hmac float:', hmacFloat.toFixed(10));
console.log('  plain float:', plainFloat.toFixed(10));
console.log('  ours:', ourFloat.toFixed(10));
if (Math.abs(ourFloat - hmacFloat) < 1e-15) console.log('  -> using HMAC (good)\n');
else if (Math.abs(ourFloat - plainFloat) < 1e-15) console.log('  -> using plain sha256 (BAD!)\n');
else console.log('  -> different algo?\n');

// bucket symmetry (left half vs right half)
console.log('bucket symmetry test:');
let left = 0, right = 0;
for (let n = 0; n < 50000; n++) {
    const b = verify(serverSeed, clientSeed, n, 16).bucket;
    if (b < 8) left++;
    else if (b > 8) right++;
}
const lPct = (left / (left + right) * 100).toFixed(2);
console.log(`  left: ${lPct}%, right: ${(100 - lPct).toFixed(2)}%`);
console.log(Math.abs(50 - lPct) < 0.5 ? '  -> balanced\n' : '  -> biased?\n');

// bucket distribution against winna's probability table
console.log('distribution check:');
const counts = new Array(17).fill(0);
for (let n = 0; n < 50000; n++) {
    counts[verify(serverSeed, clientSeed, n, 16).bucket]++;
}

let chiSq = 0;
const probs = PROB_TABLES.medium[16];
for (let k = 0; k <= 16; k++) {
    const exp = Math.round(probs[k] * 50000);
    chiSq += exp > 0 ? Math.pow(counts[k] - exp, 2) / exp : 0;
}
console.log(`  chi-sq: ${chiSq.toFixed(2)} (critical ~26.3)`);
console.log(chiSq < 26.3 ? '  -> fair\n' : '  -> check\n');

// theoretical RTP using actual probability tables (not binomial)
console.log('theoretical RTP:');
for (const [pins, difficulties] of Object.entries(PAYOUTS)) {
    for (const [difficulty, mult] of Object.entries(difficulties)) {
        const p = PROB_TABLES[difficulty]?.[parseInt(pins)];
        if (!p) continue;
        let rtp = 0;
        for (let k = 0; k < mult.length; k++) {
            rtp += p[k] * mult[k];
        }
        console.log(`  ${pins}p ${difficulty}: ${(rtp * 100).toFixed(2)}%`);
    }
}
